/*******************************************************************************/
 //Lab09
 //Creation Date: 12/09/2021
 //Description of Lab09:
 //Creating the double player Pong game! Using Tiva & booster board...
 //Code for controlling paddle 2 with Joystick on other board...
 /******************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <math.h>
#include <time.h>
#include <stdlib.h>
#include "inc/hw_types.h"
#include "inc/hw_memmap.h"
#include "driverlib/sysctl.h"
#include "driverlib/debug.h"
#include "driverlib/adc.h"
#include "driverlib/gpio.h"
#include "driverlib/uart.h"
#include "driverlib/interrupt.h"
#include "driverlib/pin_map.h"
#include "tm4c123gh6pm.h"
#include "ST7735.h"
#include "PLL.h"
#include "TM4C123.h"

uint32_t ui32ADC0Value[0];               // Getting the converted Value...
volatile uint32_t ui32ADC_results = 0;   // Variable to store ADC converted results...
uint32_t uartData1;                      // Sending the UART data variable...
volatile char TX_BUFFER[0];              // Variable to transferring data...



/****************************************************/
/* Function: main

 * Description: main routine to execute the one player
   pong game. If ball pass is missed by player/paddle it
   restarts on its own.

 * Arguments: void

 * Return: 0 on clean exit, integer other than 0 for
   any error
 */
/****************************************************/

int main()
{

    TX_BUFFER[0] = 'U'; // Initializing the variable...

    // Clk, GPIO and ADC Peripheral enable...
    SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC0);                                        // ADC Module 0 Enable...
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);                                       // GPIO Port D Enable....

    //UART Peripheral enable and configuration...
    SysCtlPeripheralEnable(SYSCTL_PERIPH_UART1);                                       // UART1 module enable...
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);                                       // GPIO port B enable for UART PIN usage...
    GPIOPinConfigure(GPIO_PB0_U1RX);                                                   // Setting PB0 as receiver pin...
    GPIOPinConfigure(GPIO_PB1_U1TX);                                                   // Setting PB1 as transmitter pin...
    GPIOPinTypeUART(GPIO_PORTB_BASE, GPIO_PIN_0 | GPIO_PIN_1);                         // PortB pin 0 and 1 for UART...
    UARTConfigSetExpClk(UART1_BASE, SysCtlClockGet(), 115200,(UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE | UART_CONFIG_PAR_NONE));   // UART peripheral parameter setting for configuration...
    UARTEnable(UART1_BASE);                                                            // Enable the UART peripheral...

    //ADC module Configuration...
    ADCSequenceDisable(ADC0_BASE, 3);                                                  // Sequencer disable for configuration...
    ADCReferenceSet(ADC0_BASE, ADC_REF_INT);                                           // Setting ADC reference voltage...
    ADCSequenceConfigure(ADC0_BASE, 3, ADC_TRIGGER_PROCESSOR, 0);                      // Trigger Configuration...
    ADCSequenceStepConfigure(ADC0_BASE, 3, 0,ADC_CTL_CH4 | ADC_CTL_IE | ADC_CTL_END);  // Setting step 0...
    ADCSequenceEnable(ADC0_BASE, 3);                                                   // Sequencer enable...
    ADCIntEnable(ADC0_BASE, 3);                                                        // Interrupt enable...

    GPIOPinTypeADC(GPIO_PORTD_BASE, GPIO_PIN_3);                                       // Analog input channel...
    SysCtlDelay(3);                                                                    // Delay function with 3 millisecond...

    while (1)
    {
        while (1)
        {
            ADCIntClear(ADC0_BASE, 3);                       // Clear interrupt flag...
            ADCProcessorTrigger(ADC0_BASE, 3);               // Trigger Sequencer...
            while (!ADCIntStatus(ADC0_BASE, 3, false)){}     // Wait for flag to set for conversion completion...
            ADCSequenceDataGet(ADC0_BASE, 3, ui32ADC0Value); // Reading the conversion result...
            ui32ADC_results = ui32ADC0Value[0];              // Storing the converted value to the variable...

            // If Converted ADC value is less than 1900....
            if (ui32ADC_results < 1900)
            {
                TX_BUFFER[0] = 'U';                          // U flag to go up...
                SysCtlDelay(5);                              // Delay 5 ms...
                UARTCharPut(UART1_BASE, TX_BUFFER[0]);       // Sending the 'U' Flag..
            }
            // If Converted ADC value is greater than 2100....
            else if (ui32ADC_results > 2100)
            {
                TX_BUFFER[0] = 'F';                          // F flag to go down...
                SysCtlDelay(5);                              // Delay 5 ms...
                UARTCharPut(UART1_BASE, TX_BUFFER[0]);       // Sending the 'F' Flag...
            }
            // If Converted ADC value is greater than 1900 and less than 2100....
            else
            {
                TX_BUFFER[0] = 'S';                          // S flag to stay there...
                SysCtlDelay(5);                              // Delay 5 ms...
                UARTCharPut(UART1_BASE, TX_BUFFER[0]);       // Sending the 'S' Flag...
            };
        }
    }
}